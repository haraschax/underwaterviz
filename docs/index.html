<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="/">
  <title>Scripps Underwater Camera Log</title>
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIHN0cm9rZT0ibm9uZSIgZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xNi42OSA3LjQ0YTYuOTczIDYuOTczIDAgMCAwIC0xLjY5IDQuNTZjMCAxLjc0NyAuNjQgMy4zNDUgMS42OTkgNC41NzEiIC8+PHBhdGggZD0iTTIgOS41MDRjNy43MTUgOC42NDcgMTQuNzUgMTAuMjY1IDIwIDIuNDk4Yy01LjI1IC03Ljc2MSAtMTIuMjg1IC02LjE0MiAtMjAgMi41MDQiIC8+PHBhdGggZD0iTTE4IDExdi4wMSIgLz48cGF0aCBkPSJNMTEuNSAxMC41Yy0uNjY3IDEgLS42NjcgMiAwIDMiIC8+PC9zdmc+' />
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      color: #333;
      margin: 0;
      padding: 0 20px;
    }
    h1 {
      text-align: center;
      margin-top: 20px;
    }
    #breadcrumb {
      margin: 20px 0;
      font-size: 14px;
    }
    #breadcrumb span {
      color: #0074d9;
      cursor: pointer;
    }
    #breadcrumb span + span:before {
      content: ' / ';
      color: #555;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .item {
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px 15px;
      min-width: 80px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .item:hover {
      background-color: #f0f8ff;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 10px;
    }
    .grid img {
      width: 100%;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      cursor: pointer;
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .overlay-container {
      position: relative;
      max-width: 90%;
      max-height: 90%;
    }
    .overlay-container img {
      max-width: 100%;
      max-height: 90vh;
    }
    .overlay-label {
      position: absolute;
      bottom: 8px;
      left: 8px;
      padding: 4px 8px;
      font-size: 16px;
      color: white;
      background-color: rgba(0,0,0,0.6);
      border-radius: 3px;
    }
    .overlay-vis {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 16px;
      font-weight: bold;
      border-radius: 3px;
      color: white;
    }
    .loading {
      text-align: center;
      padding: 40px;
      font-size: 16px;
      color: #888;
    }
    .vis-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      padding: 3px 6px;
      font-size: 12px;
      font-weight: bold;
      border-radius: 3px;
      color: white;
    }
  </style>
</head>
<body>
  <h1>Scripps Underwater Camera Log</h1>
  <div id="breadcrumb"></div>
  <div id="content"></div>

  <script>
    const apiBase = 'https://api.github.com/repos/haraschax/underwaterviz/contents/snapshots';
    const rawBase = 'https://raw.githubusercontent.com/haraschax/underwaterviz/master/snapshots';

    const breadcrumbDiv = document.getElementById('breadcrumb');
    const contentDiv = document.getElementById('content');

    const monthNames = [
      'January','February','March','April','May','June',
      'July','August','September','October','November','December'
    ];
    const monthAbbrev = [
      'jan','feb','mar','apr','may','jun',
      'jul','aug','sep','oct','nov','dec'
    ];

    let currentYear = null;
    let currentMonth = null;

    // Visibility data loaded from CSV
    let visibilityData = {};

    // Overlay for full-screen image view
    const overlay = document.createElement('div');
    overlay.className = 'overlay';
    const overlayContainer = document.createElement('div');
    overlayContainer.className = 'overlay-container';
    const overlayImg = document.createElement('img');
    const overlayLabel = document.createElement('div');
    overlayLabel.className = 'overlay-label';
    const overlayVis = document.createElement('div');
    overlayVis.className = 'overlay-vis';
    overlayContainer.appendChild(overlayImg);
    overlayContainer.appendChild(overlayLabel);
    overlayContainer.appendChild(overlayVis);
    overlay.appendChild(overlayContainer);
    overlay.addEventListener('click', () => {
      overlay.style.display = 'none';
    });
    document.body.appendChild(overlay);

    function openModal(src, alt = '', visFt = null, conditions = '') {
      overlayImg.src = src;
      overlayImg.alt = alt;
      overlayLabel.textContent = alt;
      if (visFt != null && !isNaN(visFt)) {
        overlayVis.textContent = `~${Math.round(visFt)} ft`;
        if (conditions) overlayVis.title = conditions;
        if (visFt >= 20) overlayVis.style.backgroundColor = 'rgba(0, 150, 0, 0.75)';
        else if (visFt >= 12) overlayVis.style.backgroundColor = 'rgba(0, 120, 200, 0.75)';
        else overlayVis.style.backgroundColor = 'rgba(200, 80, 0, 0.75)';
        overlayVis.style.display = '';
      } else {
        overlayVis.style.display = 'none';
      }
      overlay.style.display = 'flex';
    }

    // --- Visibility CSV loading ---

    async function loadVisibilityData() {
      try {
        const response = await fetch('visibility.csv');
        if (!response.ok) return;
        const text = await response.text();
        const lines = text.trim().split('\n');
        if (lines.length < 2) return;
        // Parse CSV: timestamp,visibility_ft,conditions
        for (let i = 1; i < lines.length; i++) {
          const match = lines[i].match(/^([^,]+),([^,]*),(.*)/);
          if (!match) continue;
          const ts = match[1].trim();
          const vis = match[2].trim();
          const cond = match[3].trim().replace(/^"|"$/g, '');
          // Key by "YYYY-MM-DD HH" (first 13 chars of timestamp)
          const key = ts.substring(0, 13);
          visibilityData[key] = {
            visibility_ft: vis === '' ? null : parseFloat(vis),
            conditions: cond
          };
        }
      } catch (e) {
        console.error('Failed to load visibility data:', e);
      }
    }

    function getVisibility(year, month, day, hour) {
      const key = `${year}-${month}-${String(day).padStart(2, '0')} ${String(hour).padStart(2, '0')}`;
      return visibilityData[key] || null;
    }

    function createVisBadge(visFt, conditions) {
      const badge = document.createElement('div');
      badge.className = 'vis-badge';
      if (visFt == null || isNaN(visFt)) {
        badge.textContent = 'nan';
        badge.style.backgroundColor = 'rgba(100, 100, 100, 0.75)';
      } else {
        badge.textContent = `~${Math.round(visFt)} ft`;
        if (conditions) badge.title = conditions;
        if (visFt >= 20) {
          badge.style.backgroundColor = 'rgba(0, 150, 0, 0.75)';
        } else if (visFt >= 12) {
          badge.style.backgroundColor = 'rgba(0, 120, 200, 0.75)';
        } else {
          badge.style.backgroundColor = 'rgba(200, 80, 0, 0.75)';
        }
      }
      return badge;
    }

    // --- URL routing helpers ---

    function monthSlug(year, month) {
      const mIdx = parseInt(month, 10) - 1;
      return `${year}${monthAbbrev[mIdx]}`;
    }

    function parseMonthSlug(slug) {
      // Parse "2026jan" -> { year: "2026", month: "01" }
      const match = slug.match(/^(\d{4})([a-z]{3})$/);
      if (!match) return null;
      const year = match[1];
      const abbr = match[2];
      const idx = monthAbbrev.indexOf(abbr);
      if (idx === -1) return null;
      return { year, month: String(idx + 1).padStart(2, '0') };
    }

    // --- GitHub API fetch with caching ---

    async function fetchDir(path = '') {
      const cacheKey = path || 'root';
      try {
        const cachedRaw = sessionStorage.getItem(`uw_cache_${cacheKey}`);
        if (cachedRaw) {
          try {
            const cached = JSON.parse(cachedRaw);
            const oneHour = 60 * 60 * 1000;
            if (Date.now() - cached.time < oneHour) {
              return cached.data;
            }
            sessionStorage.removeItem(`uw_cache_${cacheKey}`);
          } catch (e) {
            sessionStorage.removeItem(`uw_cache_${cacheKey}`);
          }
        }
      } catch (e) {}
      try {
        const url = path ? `${apiBase}/${path}` : apiBase;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch ${url}: ${response.status}`);
        }
        const data = await response.json();
        try {
          sessionStorage.setItem(`uw_cache_${cacheKey}`, JSON.stringify({ data, time: Date.now() }));
        } catch (e) {}
        return data;
      } catch (err) {
        console.error(err);
        return [];
      }
    }

    // --- Breadcrumb ---

    function setBreadcrumb(parts) {
      breadcrumbDiv.innerHTML = '';
      parts.forEach((part, idx) => {
        const span = document.createElement('span');
        span.textContent = part;
        span.addEventListener('click', () => {
          if (parts[0] === 'Home') {
            if (idx === 0) {
              history.pushState({ view: 'months' }, '', '/');
              loadAllMonths();
            } else if (idx === 1) {
              if (currentYear && currentMonth) {
                loadDays(currentYear, currentMonth);
              }
            }
          }
        });
        breadcrumbDiv.appendChild(span);
      });
    }

    function createItem(name, onClick) {
      const div = document.createElement('div');
      div.className = 'item';
      div.textContent = name;
      div.addEventListener('click', onClick);
      return div;
    }

    // --- Last 7 days ---

    async function loadLast7DaysImages() {
      try {
        const response = await fetch('last7days/last7days.json');
        if (!response.ok) return;
        const imagesInfo = await response.json();
        if (!Array.isArray(imagesInfo) || imagesInfo.length === 0) return;

        const section = document.createElement('div');
        const heading = document.createElement('h2');
        heading.textContent = 'Midday images from the last 7 days';
        heading.style.textAlign = 'center';
        section.appendChild(heading);
        const grid = document.createElement('div');
        grid.className = 'grid';

        imagesInfo.forEach(info => {
          const wrapper = document.createElement('div');
          wrapper.style.position = 'relative';
          const img = document.createElement('img');
          img.src = `last7days/${info.file}`;
          const dateLabel = `${info.date} ${info.time.padStart(2, '0')}:00`;
          img.alt = dateLabel;
          img.title = dateLabel;
          img.style.display = 'block';
          const label = document.createElement('div');
          label.textContent = dateLabel;
          label.style.position = 'absolute';
          label.style.bottom = '4px';
          label.style.left = '4px';
          label.style.padding = '2px 4px';
          label.style.fontSize = '12px';
          label.style.color = 'white';
          label.style.backgroundColor = 'rgba(0,0,0,0.5)';
          wrapper.appendChild(img);
          wrapper.appendChild(label);

          // Visibility badge from manifest
          const visFt = info.visibility_ft != null ? info.visibility_ft : null;
          const cond = info.conditions || '';
          wrapper.appendChild(createVisBadge(visFt, cond));

          wrapper.addEventListener('click', () => openModal(img.src, dateLabel, visFt, cond));
          grid.appendChild(wrapper);
        });

        section.appendChild(grid);
        contentDiv.appendChild(section);
      } catch (err) {
        console.error(err);
      }
    }

    // --- Visibility chart ---

    function renderVisibilityChart(parent) {
      // Collect ALL valid visibility points and group by date
      const allPoints = [];
      const dailyPoints = {};
      for (const [key, val] of Object.entries(visibilityData)) {
        if (val.visibility_ft == null || isNaN(val.visibility_ft)) continue;
        const date = key.substring(0, 10);
        const hour = parseInt(key.substring(11, 13), 10);
        allPoints.push({ date, hour, vis: val.visibility_ft });
        if (!dailyPoints[date]) dailyPoints[date] = [];
        dailyPoints[date].push(val.visibility_ft);
      }

      const dates = Object.keys(dailyPoints).sort();
      if (dates.length < 2) return;

      // Compute mean for each day (NaN values already filtered out)
      function mean(arr) {
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      }
      const dailyMean = dates.map(d => mean(dailyPoints[d]));

      // Date index map for x-positioning
      const dateIdx = {};
      dates.forEach((d, i) => dateIdx[d] = i);

      const section = document.createElement('div');
      section.style.margin = '20px auto';
      section.style.maxWidth = '900px';

      const heading = document.createElement('h2');
      heading.textContent = 'Visibility Trend';
      heading.style.textAlign = 'center';
      section.appendChild(heading);

      const canvas = document.createElement('canvas');
      canvas.width = 900;
      canvas.height = 300;
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.backgroundColor = '#fff';
      canvas.style.border = '1px solid #ddd';
      canvas.style.borderRadius = '4px';
      section.appendChild(canvas);
      parent.appendChild(section);

      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const padL = 50, padR = 20, padT = 20, padB = 50;
      const plotW = W - padL - padR;
      const plotH = H - padT - padB;
      const maxVis = 40;

      function dateX(i) { return padL + (i / (dates.length - 1)) * plotW; }
      function visY(v) { return padT + plotH - (Math.min(v, maxVis) / maxVis) * plotH; }

      // Grid lines
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let v = 0; v <= maxVis; v += 5) {
        const y = visY(v);
        ctx.beginPath();
        ctx.moveTo(padL, y);
        ctx.lineTo(W - padR, y);
        ctx.stroke();
      }

      // Y-axis labels
      ctx.fillStyle = '#666';
      ctx.font = '11px Arial';
      ctx.textAlign = 'right';
      for (let v = 0; v <= maxVis; v += 10) {
        ctx.fillText(`${v} ft`, padL - 6, visY(v) + 4);
      }

      // X-axis labels
      ctx.textAlign = 'center';
      const labelCount = Math.min(dates.length, 8);
      const labelStep = Math.max(1, Math.floor(dates.length / labelCount));
      for (let i = 0; i < dates.length; i += labelStep) {
        const parts = dates[i].split('-');
        const mo = monthAbbrev[parseInt(parts[1], 10) - 1];
        const day = parseInt(parts[2], 10);
        ctx.fillText(`${mo} ${day}`, dateX(i), H - padB + 16);
      }

      // Color function
      function visColor(v) {
        if (v >= 20) return 'rgba(0, 150, 0, 0.45)';
        if (v >= 12) return 'rgba(0, 120, 200, 0.45)';
        return 'rgba(200, 80, 0, 0.45)';
      }

      // Draw scatter points (every data point)
      for (const pt of allPoints) {
        const i = dateIdx[pt.date];
        if (i == null) continue;
        const x = dateX(i);
        const y = visY(pt.vis);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = visColor(pt.vis);
        ctx.fill();
      }

      // Draw daily mean line
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < dates.length; i++) {
        const x = dateX(i);
        const y = visY(dailyMean[i]);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // --- All months view (home) ---

    async function loadAllMonths() {
      contentDiv.innerHTML = '';
      if (!history.state || history.state.view !== 'months') {
        history.replaceState({ view: 'months' }, '', '/');
      }
      setBreadcrumb(['Home']);
      await loadLast7DaysImages();
      renderVisibilityChart(contentDiv);

      const heading = document.createElement('h2');
      heading.textContent = 'Browse historical pictures';
      heading.style.textAlign = 'center';
      heading.style.marginTop = '20px';
      contentDiv.appendChild(heading);

      try {
        const response = await fetch('months.json');
        if (!response.ok) throw new Error('Failed to load months manifest');
        const monthsList = await response.json();
        if (!Array.isArray(monthsList) || monthsList.length === 0) throw new Error('Invalid months manifest');

        monthsList.sort((a, b) => {
          const ya = parseInt(a.year, 10), yb = parseInt(b.year, 10);
          if (ya !== yb) return yb - ya;
          return parseInt(b.month, 10) - parseInt(a.month, 10);
        });

        const container = document.createElement('div');
        container.className = 'container';
        monthsList.forEach(entry => {
          const mNum = parseInt(entry.month, 10);
          const displayName = `${monthNames[mNum - 1]} ${entry.year}`;
          container.appendChild(createItem(displayName, () => loadDays(entry.year, entry.month, true)));
        });
        contentDiv.appendChild(container);
      } catch (err) {
        console.error(err);
        const msg = document.createElement('p');
        msg.textContent = 'No historical images are available.';
        msg.style.textAlign = 'center';
        msg.style.marginTop = '15px';
        contentDiv.appendChild(msg);
      }

      const heading2 = document.createElement('h2');
      heading2.textContent = 'The Scripps Underwater Cam';
      heading2.style.textAlign = 'center';
      heading2.style.marginTop = '18px';
      contentDiv.appendChild(heading2);

      const infoP = document.createElement('p');
      infoP.append('This website is just a historical log of the Scripps Pier Underwater Camera: ');
      const link = document.createElement('a');
      link.href = 'https://coollab.ucsd.edu/pierviz/';
      link.textContent = 'https://coollab.ucsd.edu/pierviz/';
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
      infoP.appendChild(link);
      infoP.append('. This website is completely open-source, feel free to contribute: ');
      const link2 = document.createElement('a');
      link2.href = 'https://github.com/haraschax/underwaterviz';
      link2.textContent = 'https://github.com/haraschax/underwaterviz';
      link2.target = '_blank';
      link2.rel = 'noopener noreferrer';
      infoP.appendChild(link2);
      infoP.append(
        '. The underwater cam is a great tool to estimate underwater visibility in La Jolla for snorkeling or diving.',
        document.createElement('br'),
        document.createElement('br'),
        'Water visibility can be estimated from the pier pilings and water colour. ',
        'The closest pier piling on the right is 1.2m (4 ft) away from the camera and ',
        'the piling on the right back of the screen is 3.4m (11 ft). The back left ',
        'piling is 4.3m (14 ft) away from the camera and may only be visible when ocean ',
        'conditions are calm and clear (light blue water). If you can see two pier ',
        'pilings on the left, the farthest one is 9m (30 ft) away, and visibility rarely ',
        'gets this good. Below is an example of great visibility:',
      );
      infoP.style.marginTop = '20px';
      infoP.style.maxWidth = '800px';
      infoP.style.marginLeft = 'auto';
      infoP.style.marginRight = 'auto';
      infoP.style.lineHeight = '1.4';
      contentDiv.appendChild(infoP);

      const exampleImg = document.createElement('img');
      exampleImg.src = 'great_visibility.png';
      exampleImg.alt = 'Example of great underwater visibility';
      exampleImg.style.display = 'block';
      exampleImg.style.margin = '10px auto 30px';
      exampleImg.style.maxWidth = '800px';
      exampleImg.style.width = '100%';
      contentDiv.appendChild(exampleImg);
    }

    // --- Month view (flattened days) ---

    async function loadDays(year, month, pushHistory = false) {
      currentYear = year;
      currentMonth = month;
      const slug = monthSlug(year, month);

      if (pushHistory) {
        history.pushState({ view: 'month', year, month }, '', `/${slug}`);
      }

      const monthDisplay = `${monthNames[parseInt(month, 10) - 1]} ${year}`;
      setBreadcrumb(['Home', monthDisplay]);
      contentDiv.innerHTML = '';

      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading';
      loadingDiv.textContent = 'Loading images...';
      contentDiv.appendChild(loadingDiv);

      const items = await fetchDir(`${year}/${month}`);
      const dayDirs = items.filter(item => item.type === 'dir');
      const images = [];
      for (const dir of dayDirs) {
        const day = dir.name;
        const dayItems = await fetchDir(`${year}/${month}/${day}`);
        const files = dayItems.filter(item => item.type === 'file');
        files.forEach(file => {
          const hour = parseInt(file.name.split('.')[0], 10);
          if (hour >= 6 && hour < 20) {
            images.push({ year, month, day, file: file.name });
          }
        });
      }
      images.sort((a, b) => {
        const da = parseInt(a.day, 10), db = parseInt(b.day, 10);
        if (da !== db) return da - db;
        return parseInt(a.file.split('.')[0], 10) - parseInt(b.file.split('.')[0], 10);
      });

      contentDiv.innerHTML = '';
      const grid = document.createElement('div');
      grid.className = 'grid';

      images.forEach(info => {
        const wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        const img = document.createElement('img');
        const hourStr = info.file.split('.')[0].padStart(2, '0');
        img.src = `thumbnails/${info.year}/${info.month}/${info.day}/${hourStr}.jpg`;
        const fullSrc = `${rawBase}/${info.year}/${info.month}/${info.day}/${info.file}`;
        const dateLabel = `${info.year}-${info.month}-${info.day} ${hourStr}:00`;
        img.alt = dateLabel;
        img.title = dateLabel;
        img.style.display = 'block';
        const label = document.createElement('div');
        label.textContent = dateLabel;
        label.style.position = 'absolute';
        label.style.bottom = '4px';
        label.style.left = '4px';
        label.style.padding = '2px 4px';
        label.style.fontSize = '12px';
        label.style.color = 'white';
        label.style.backgroundColor = 'rgba(0,0,0,0.5)';
        wrapper.appendChild(img);
        wrapper.appendChild(label);

        // Visibility badge from CSV data
        const hour = parseInt(info.file.split('.')[0], 10);
        const visInfo = getVisibility(info.year, info.month, info.day, hour);
        const visFt = visInfo ? visInfo.visibility_ft : null;
        const cond = visInfo ? visInfo.conditions : '';
        wrapper.appendChild(createVisBadge(visFt, cond));

        wrapper.addEventListener('click', () => openModal(fullSrc, dateLabel, visFt, cond));
        grid.appendChild(wrapper);
      });

      contentDiv.appendChild(grid);
    }

    // --- URL routing on page load ---

    function routeFromURL() {
      // Check for redirect from 404.html
      const redirectPath = sessionStorage.getItem('redirect_path');
      if (redirectPath) sessionStorage.removeItem('redirect_path');
      const path = (redirectPath || window.location.pathname).replace(/^\/+|\/+$/g, '');
      if (path) {
        const parsed = parseMonthSlug(path);
        if (parsed) {
          history.replaceState({ view: 'month', year: parsed.year, month: parsed.month }, '', `/${path}`);
          loadDays(parsed.year, parsed.month);
          return;
        }
      }
      loadAllMonths();
    }

    // Handle browser back/forward
    window.addEventListener('popstate', (event) => {
      const state = event.state;
      if (!state || !state.view || state.view === 'months') {
        loadAllMonths();
      } else if (state.view === 'month') {
        loadDays(state.year, state.month);
      }
    });

    // Load visibility data first, then route
    loadVisibilityData().then(() => routeFromURL());
  </script>
</body>
</html>
